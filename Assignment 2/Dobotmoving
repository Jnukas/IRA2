#!/usr/bin/env python3
# room_only.py — generate everything first, then move (placements preserved)
from __future__ import annotations

from pathlib import Path
import math
import time
import importlib.util
import inspect

import numpy as np
import swift
import spatialgeometry as sg
import roboticstoolbox as rtb
from spatialmath import SE3

from room_utils import apply_swift_browser_fix, make_room
from ir_support.robots.LinearUR3 import LinearUR3


# ===== Motion toggles (no placement changes) =====
RUN_WIGGLE_CR3  = False
RUN_WIGGLE_CR16 = False
RUN_RAIL_SLIDE  = False
FPS = 60
DT = 1.0 / FPS


# --- helpers for dynamic loading ---
def _load_robot_class(pyfile: Path, prefer_names: tuple[str, ...]) -> type:
    """Dynamic loader that returns the first matching RTB robot class."""
    if not pyfile.exists():
        raise FileNotFoundError(f"Robot file not found: {pyfile}")

    spec = importlib.util.spec_from_file_location("user_robot_module", str(pyfile))
    mod = importlib.util.module_from_spec(spec)
    assert spec.loader is not None
    spec.loader.exec_module(mod)

    # 1) try preferred names first
    for name in prefer_names:
        if hasattr(mod, name) and inspect.isclass(getattr(mod, name)):
            return getattr(mod, name)

    # 2) else scan for any RTB robot subclass
    candidates = []
    RobotBase = getattr(rtb, "Robot", tuple())
    for name, obj in vars(mod).items():
        if inspect.isclass(obj):
            try:
                if issubclass(obj, (rtb.ERobot, rtb.DHRobot, RobotBase)):  # type: ignore[arg-type]
                    candidates.append((name, obj))
            except Exception:
                pass

    if candidates:
        print(f"[loader] Using {candidates[0][0]} from {pyfile.name}")
        return candidates[0][1]

    raise ImportError(f"No robot class found in {pyfile.name}. "
                      f"Export a class like `class MyBot(DHRobot/ERobot): ...`.")


# --- helpers ---
def _T_translation(T_like):
    """Return (x,y,z) from an SE3 or a 4x4 ndarray."""
    try:
        t = T_like.t  # SE3
        return float(t[0]), float(t[1]), float(t[2])
    except Exception:
        M = np.asarray(T_like)
        return float(M[0, 3]), float(M[1, 3]), float(M[2, 3])


def solve_ik_relaxed(robot, T: SE3, qseed=None):
    """
    IK with fallbacks: full 6D → relax yaw → position-only.
    Returns (q, success: bool).
    """
    if qseed is None:
        qseed = getattr(robot, "q", np.zeros(robot.n))
    sol = robot.ikine_LM(T, q0=qseed)
    if sol.success:
        return sol.q, True
    sol = robot.ikine_LM(T, q0=qseed, mask=[1, 1, 1, 1, 1, 0])
    if sol.success:
        return sol.q, True
    sol = robot.ikine_LM(T, q0=qseed, mask=[1, 1, 1, 0, 0, 0])
    return sol.q, sol.success


def animate_jtraj(robot, env, q_start, q_goal, seconds, dt=DT):
    """
    Joint-space move using jtraj (LSPB profile by default).
    """
    t = np.arange(0.0, max(seconds, dt) + dt, dt)
    traj = rtb.jtraj(np.array(q_start), np.array(q_goal), t)
    for qk in traj.q:
        robot.q = qk
        env.step(dt)
        time.sleep(dt)
    return traj.q[-1]  # final joint vector


def main():
    # -------------------------
    # Launch Swift
    # -------------------------
    apply_swift_browser_fix()
    env = swift.Swift()
    env.launch(realtime=True, browser=None, host="127.0.0.1", port=52100, ws_port=53100)

    # -------------------------
    # Room
    # -------------------------
    ROOM_W = 6.0
    ROOM_D = 6.0
    FLOOR_TOP = 0.005

    make_room(
        env,
        room_w=ROOM_W,
        room_d=ROOM_D,
        floor_t=0.10,
        open_side="+Y",
        floor_top=FLOOR_TOP,
    )

    # -------------------------
    # Oven (STL)
    # -------------------------
    oven_path = Path(__file__).parent / "assets" / "oven2.stl"
    oven = sg.Mesh(
        filename=str(oven_path),
        scale=[0.05, 0.05, 0.05],
        color=[0.70, 0.70, 0.70, 1.0],
    )
    z_lift = 0.0
    try:
        import trimesh
        tm = trimesh.load_mesh(str(oven_path), process=False)
        zmin = float(tm.bounds[0, 2])
        z_lift = -zmin * 0.001
        size_m = (tm.bounds[1] - tm.bounds[0]) * 0.001
        print(f"Oven size (m): X={size_m[0]:.3f}  Y={size_m[1]:.3f}  Z={size_m[2]:.3f}")
    except Exception:
        pass
    oven.T = SE3(0.0, -ROOM_D / 2 + 0.60, FLOOR_TOP + z_lift) @ SE3.Rz(math.pi)
    env.add(oven)

    # -------------------------
    # Table (STL)
    # -------------------------
    table_path = Path(__file__).parent / "assets" / "table.stl"
    table = sg.Mesh(
        filename=str(table_path),
        scale=[1, 1, 1],
        color=[0.82, 0.82, 0.82, 1.0],
    )
    z_lift_table = 0.0
    try:
        import trimesh
        tm_tbl = trimesh.load_mesh(str(table_path), process=False)
        zmin_tbl = float(tm_tbl.bounds[0, 2])
        z_lift_table = -zmin_tbl * 1.0
        size_tbl_m = (tm_tbl.bounds[1] - tm_tbl.bounds[0]) * 1.0
        print(f"Table size (m): X={size_tbl_m[0]:.3f}  Y={size_tbl_m[1]:.3f}  Z={size_tbl_m[2]:.3f}")
    except Exception:
        size_tbl_m = None
    try:
        table_top_z = FLOOR_TOP + z_lift_table + float(size_tbl_m[2])  # noqa: F823
    except Exception:
        table_top_z = FLOOR_TOP + z_lift_table + 0.75
    table.T = SE3(-1.5, -0.5, FLOOR_TOP + z_lift_table) @ SE3.Rz(math.pi / 2)
    env.add(table)

    # -------------------------
    # Pot (STL)
    # -------------------------
    pot_path = Path(__file__).parent / "assets" / "Potwithoutthelid.stl"
    pot = sg.Mesh(
        filename=str(pot_path),
        scale=[0.002, 0.002, 0.002],
        color=[0.70, 0.70, 0.70, 1.0],
    )
    try:
        import trimesh
        tm = trimesh.load_mesh(str(pot_path), process=False)
        zmin = float(tm.bounds[0, 2])
        z_lift = -zmin * 0.001
        size_m = (tm.bounds[1] - tm.bounds[0]) * 0.001
        print(f"Pot size (m): X={size_m[0]:.3f}  Y={size_m[1]:.3f}  Z={size_m[2]:.3f}")
    except Exception:
        pass
    pot.T = SE3(-2, -0.5, 0.945 + 0.003) @ SE3.Rz(0.0)  # manual placement
    env.add(pot)

    # -------------------------
    # Work table (STL)
    # -------------------------
    wt_path = Path(__file__).parent / "assets" / "rightwayup.stl"
    wt = sg.Mesh(
        filename=str(wt_path),
        scale=[0.001, 0.001, 0.001],
        color=[0.70, 0.70, 0.70, 1.0],
    )
    try:
        import trimesh
        tm = trimesh.load_mesh(str(wt_path), process=False)
        zmin = float(tm.bounds[0, 2])
        _ = (tm.bounds[1] - tm.bounds[0]) * 0.001
    except Exception:
        pass
    wt.T = SE3(0, 0, 0) @ SE3.Rz(0)
    env.add(wt)

    # -------------------------
    # Linear UR3
    # -------------------------
    ur3 = LinearUR3()
    RAIL_X0 = 0.4
    RAIL_Y  = -1
    RAIL_Z  = FLOOR_TOP + 0.003
    YAW     = math.pi / 90
    ur3.base = SE3(RAIL_X0, RAIL_Y, RAIL_Z) @ SE3.Rz(YAW) @ ur3.base
    ur3.add_to_env(env)

    # -------------------------
    # CR3
    # -------------------------
    CR3_FILE = Path(__file__).parent / "Cr3UR3editon.py"
    CR3Class = _load_robot_class(CR3_FILE, ("CR3", "Cr3UR3editon", "DobotCR3", "RobotCR3"))
    cr3 = CR3Class()

    CR3_X, CR3_Y = -1.2, 0.45
    CR3_Z        = 0.945 + 0.003
    CR3_YAW      = -math.pi / 2
    base0_cr3 = getattr(cr3, "base", SE3())
    cr3.base = SE3(CR3_X, CR3_Y, CR3_Z) @ SE3.Rz(CR3_YAW) @ base0_cr3
    try:
        q_spawn = cr3.q.copy()
    except Exception:
        q_spawn = np.zeros(getattr(cr3, "n", 6))
    cr3.q = q_spawn
    if hasattr(cr3, "qtest"):
        cr3.qtest = q_spawn
    cr3.add_to_env(env)
    env.step(0.02)

    # -------------------------
    # CR16
    # -------------------------
    CR16_FILE = Path(__file__).parent / "CR16Creator.py"
    try:
        CR16Class = _load_robot_class(CR16_FILE, ("CR16", "DobotCR16", "RobotCR16", "Cr16", "Cr16UR3Edition"))
        try:
            cr16 = CR16Class()
        except TypeError:
            cr16 = CR16Class(use_mesh=False)
    except Exception as e:
        print("[CR16] Load skipped:", e)
        cr16 = None

    if cr16 is not None:
        CR16_X, CR16_Y = -1.2, -1
        CR16_Z = 0.945 + 0.003
        CR16_YAW = +math.pi / 2
        base0_cr16 = getattr(cr16, "base", SE3())
        cr16.base = SE3(CR16_X, CR16_Y, CR16_Z) @ SE3.Rz(CR16_YAW) @ base0_cr16
        try:
            if hasattr(cr16, "q_home"):
                q_spawn16 = cr16.q_home
            elif hasattr(cr16, "qtest"):
                q_spawn16 = cr16.qtest
            else:
                q_spawn16 = cr16.q.copy()
        except Exception:
            q_spawn16 = np.zeros(getattr(cr16, "n", 6))
        cr16.q = q_spawn16
        try:
            cr16.add_to_env(env)
            env.step(0.02)
        except Exception as e:
            print("[CR16] Visual add failed:", e)

    # -------------------------
    # All visible
    # -------------------------
    env.step(0.02)
    print("[Scene] All robots added. Starting motion phase…")

    # =========================
    # Move BOTH CR3 and CR16 to the POT using JTRAJ
    # =========================
    px, py, pz = _T_translation(pot.T)

    # Common orientation: tool Z pointing down.
    R_DOWN = SE3.Rx(math.pi)

    # ---- CR3 plan (hover → touch → hover), ALL JTRAJ ----
    try:
        HOVER_Z_CR3    = 0.22      # edit this height if needed
        APPROACH_Z_CR3 = 0.08
        SEG_S_CR3      = 2.0

        T_hover_cr3 = SE3(px, py, pz + HOVER_Z_CR3) * R_DOWN
        T_touch_cr3 = SE3(px, py, pz + APPROACH_Z_CR3) * R_DOWN

        q0 = cr3.q.copy()
        q_hover, ok1 = solve_ik_relaxed(cr3, T_hover_cr3, qseed=q0)
        q_touch, ok2 = solve_ik_relaxed(cr3, T_touch_cr3, qseed=q_hover)

        if ok1:
            print("[CR3] jtraj → hover")
            q_end = animate_jtraj(cr3, env, q0, q_hover, SEG_S_CR3, dt=DT)
        else:
            print("[CR3] IK to hover failed; skipping CR3 move.")
            q_end = q0

        if ok2:
            print("[CR3] jtraj → touch")
            q_end = animate_jtraj(cr3, env, q_end, q_touch, SEG_S_CR3, dt=DT)
            print("[CR3] jtraj → back to hover")
            animate_jtraj(cr3, env, q_end, q_hover, SEG_S_CR3, dt=DT)
    except Exception as e:
        print("[CR3] Move error:", e)

    # ---- CR16 plan (hover → touch → hover), ALL JTRAJ ----
    if cr16 is not None:
        try:
            HOVER_Z_CR16    = 0.25   # edit this height if needed
            APPROACH_Z_CR16 = 0.07
            SEG_S_CR16      = 2.0

            T_hover_cr16 = SE3(px, py, pz + HOVER_Z_CR16) * R_DOWN
            T_touch_cr16 = SE3(px, py, pz + APPROACH_Z_CR16) * R_DOWN

            q0 = cr16.q.copy()
            q_hover, ok1 = solve_ik_relaxed(cr16, T_hover_cr16, qseed=q0)
            q_touch, ok2 = solve_ik_relaxed(cr16, T_touch_cr16, qseed=q_hover)

            if ok1:
                print("[CR16] jtraj → hover")
                q_end = animate_jtraj(cr16, env, q0, q_hover, SEG_S_CR16, dt=DT)
            else:
                print("[CR16] IK to hover failed; skipping CR16 move.")
                q_end = q0

            if ok2:
                print("[CR16] jtraj → touch")
                q_end = animate_jtraj(cr16, env, q_end, q_touch, SEG_S_CR16, dt=DT)
                print("[CR16] jtraj → back to hover")
                animate_jtraj(cr16, env, q_end, q_hover, SEG_S_CR16, dt=DT)
        except Exception as e:
            print("[CR16] Move error:", e)

    # =========================
    # Optional extras
    # =========================
    if RUN_WIGGLE_CR3:
        try:
            T = 2.0
            t = np.arange(0, T + DT, DT)
            qs = cr3.q.copy()
            qg = cr3.q.copy()
            j = min(2, qs.size - 1)
            qg[j] += np.deg2rad(15)
            traj = rtb.jtraj(qs, qg, t)
            for qk in traj.q:
                cr3.q = qk
                env.step(DT)
                time.sleep(DT)
        except Exception as _e:
            print("[CR3] Wiggle skipped:", _e)

    if cr16 is not None and RUN_WIGGLE_CR16:
        try:
            T = 2.0
            t = np.arange(0, T + DT, DT)
            qs = cr16.q.copy()
            qg = cr16.q.copy()
            j = min(2, qs.size - 1)
            qg[j] += np.deg2rad(12)
            traj = rtb.jtraj(qs, qg, t)
            for qk in traj.q:
                cr16.q = qk
                env.step(DT)
                time.sleep(DT)
        except Exception as _e:
            print("[CR16] Wiggle skipped:", _e)

    if RUN_RAIL_SLIDE:
        q_start = ur3.q.copy()
        q_goal  = q_start.copy()
        q_goal[0] = -0.8
        T = 3.0
        t = np.arange(0, T + DT, DT)
        traj = rtb.jtraj(q_start, q_goal, t)
        for qk in traj.q:
            ur3.q = qk
            env.step(DT)
            time.sleep(DT)

    # Camera + hold
    env.set_camera_pose([1.8, 3.4, 1.6], [0.0, -0.5, 0.8])
    print("Open Swift at http://localhost:52100")
    env.hold()


if __name__ == "__main__":
    main()
