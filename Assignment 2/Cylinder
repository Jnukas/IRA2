# === CR16 + Swift: Cylindrical overlay + Joint-Axis markers + Teach Mode ===
from CR16Creator import CR16                 # your robot class (DHRobot3D-based)
import swift
import numpy as np
import os
from spatialmath.base import tr2rpy          # for RPY readout
from ir_support import CylindricalDHRobotPlot
from spatialgeometry import Axes

# ---------------- Teach Mode ----------------
def teach_mode(robot, env):
    """
    Adds sliders (deg) for each joint and live labels for XYZ + RPY.
    Call once after adding the robot to the Swift env.
    """
    # live pose -> strings
    def pose_strings():
        T = robot.fkine(robot.q).A if hasattr(robot.fkine(robot.q), "A") else robot.fkine(robot.q)
        xyz = np.round(T[0:3, 3], 3)
        rpy = np.round(tr2rpy(T, unit="deg"), 2)
        return (
            f"X: {xyz[0]} m", f"Y: {xyz[1]} m", f"Z: {xyz[2]} m",
            f"Roll (φ): {rpy[0]}°", f"Pitch (θ): {rpy[1]}°", f"Yaw (ψ): {rpy[2]}°"
        )

    # initial labels
    xs, ys, zs, rs, ps, ys2 = pose_strings()
    label_x = swift.Label(xs);   env.add(label_x)
    label_y = swift.Label(ys);   env.add(label_y)
    label_z = swift.Label(zs);   env.add(label_z)
    label_r = swift.Label(rs);   env.add(label_r)
    label_p = swift.Label(ps);   env.add(label_p)
    label_yaw = swift.Label(ys2); env.add(label_yaw)
    labels = [label_x, label_y, label_z, label_r, label_p, label_yaw]

    # slider callback (per joint)
    def on_slider(value_deg, jindex):
        q = list(robot.q)
        q[jindex] = np.deg2rad(value_deg)

        # clamp to limits if available
        try:
            qmin, qmax = robot.links[jindex].qlim
            q[jindex] = float(np.clip(q[jindex], qmin, qmax))
        except Exception:
            pass

        robot.q = q

        # update pose labels
        xs, ys, zs, rs, ps, ys2 = pose_strings()
        labels[0].desc = xs
        labels[1].desc = ys
        labels[2].desc = zs
        labels[3].desc = rs
        labels[4].desc = ps
        labels[5].desc = ys2

    # create one slider per joint
    for j in range(robot.n):
        # limits in degrees (fallback to ±180°)
        try:
            qmin, qmax = robot.links[j].qlim
            mn_deg, mx_deg = float(np.rad2deg(qmin)), float(np.rad2deg(qmax))
        except Exception:
            mn_deg, mx_deg = -180.0, 180.0

        val_deg = float(np.rad2deg(robot.q[j]))
        val_deg = float(np.clip(val_deg, mn_deg, mx_deg))

        slider = swift.Slider(
            cb=lambda v, jj=j: on_slider(v, jj),  # capture j by value
            min=mn_deg, max=mx_deg, step=1.0,
            value=val_deg,
            desc=f"Joint {j+1}", unit='°'
        )
        env.add(slider)

    env.step(0.02)


# ---------------- Main ----------------
if __name__ == "__main__":
    # Launch Swift
    env = swift.Swift()
    env.launch(realtime=True)

    # Build & add mesh robot
    robot = CR16()
    robot.add_to_env(env)

    # Mesh path debug
    print("Mesh dir:", robot._link3D_dir)
    for k, name in robot.link3D_names.items():
        path = os.path.join(robot._link3D_dir, name + ".dae")
        try:
            size = os.path.getsize(path)
            print(k, os.path.basename(path), "size:", size)
        except OSError:
            print(k, os.path.basename(path), "MISSING")

    # Cylindrical overlay (multicolor) on the same kinematics
    cyl = CylindricalDHRobotPlot(robot, cylinder_radius=0.03, multicolor=True)
    cyl_robot = cyl.create_cylinders()
    cyl_robot.base = robot.base
    env.add(cyl_robot)

    # Joint-axis indicators at frames {0}..{n-1} (Ji rotates about +Z of frame {i-1})
    AXIS_LEN = 0.12
    joint_axes = []
    for _ in range(robot.n):
        ax = Axes(length=AXIS_LEN)
        env.add(ax)
        joint_axes.append(ax)

    legend = swift.Label("Joint markers: axes at frames {i-1}.  Blue (+Z) is the rotation axis.")
    env.add(legend)

    def update_joint_axes():
        # frames {1}..{n} at link ends; previous frames are {0}..{n-1}
        Tall = robot.fkine_all(robot.q)
        Tprev = [robot.base] + list(Tall[:-1])
        for i, ax in enumerate(joint_axes):
            ax.T = Tprev[i]

    # Enable teach mode UI
    teach_mode(robot, env)

    # Real-time update loop: keep overlay and axes in sync; process UI
    try:
        while True:
            cyl_robot.q = robot.q          # mirror joint state
            update_joint_axes()            # move axis gizmos
            env.step(0.02)                 # ~50 Hz
    except KeyboardInterrupt:
        print("\nClosing Swift environment...")
        env.close()
