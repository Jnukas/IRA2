#!/usr/bin/env python3
# cr3_swift_collision_rrt.py  (robust Cuboid mesh extraction)
import time
import numpy as np
from math import pi
from itertools import combinations

import swift
import spatialgeometry as sg
from spatialmath import SE3
from spatialmath.base import tr2rpy
import roboticstoolbox as rtb

# --- YOUR ROBOT ---
from CR16Creator import CR16

# ---------- small helpers ----------
def T_translation(T_like):
    """Return (x,y,z) from an SE3 or a 4x4 ndarray."""
    try:
        t = T_like.t
        return float(t[0]), float(t[1]), float(t[2])
    except Exception:
        M = np.asarray(T_like)
        return float(M[0, 3]), float(M[1, 3]), float(M[2, 3])

# ---------- robust Cuboid → (vertices, faces, normals) ----------
def cuboid_mesh_data(cuboid: sg.Cuboid):
    """
    Build world-space vertices, face index lists (quads), and face normals
    for a spatialgeometry.Cuboid, without using .vertices/.faces attributes.
    """
    # size
    scale = getattr(cuboid, "scale", None)
    if scale is None:
        # some versions use .size
        scale = getattr(cuboid, "size", [1.0, 1.0, 1.0])
    sx, sy, sz = [float(s) for s in scale]
    hx, hy, hz = sx / 2.0, sy / 2.0, sz / 2.0

    # local vertices (centered at origin)
    Vloc = np.array([
        [-hx, -hy, -hz],  # 0
        [ +hx, -hy, -hz], # 1
        [ +hx, +hy, -hz], # 2
        [-hx, +hy, -hz],  # 3
        [-hx, -hy, +hz],  # 4
        [ +hx, -hy, +hz], # 5
        [ +hx, +hy, +hz], # 6
        [-hx, +hy, +hz],  # 7
    ], dtype=float)

    # transform to world using cuboid.T
    T = cuboid.T if hasattr(cuboid.T, "A") else SE3(cuboid.T)
    R = T.R; t = T.t
    Vworld = (R @ Vloc.T).T + t

    # faces as quads (indices into Vworld)
    faces = [
        np.array([0, 1, 2, 3], dtype=int),  # bottom (z-)
        np.array([4, 5, 6, 7], dtype=int),  # top (z+)
        np.array([0, 1, 5, 4], dtype=int),  # y-
        np.array([3, 2, 6, 7], dtype=int),  # y+
        np.array([0, 3, 7, 4], dtype=int),  # x-
        np.array([1, 2, 6, 5], dtype=int),  # x+
    ]

    # per-face normals (world)
    normals = []
    for f in faces:
        a, b, c = Vworld[f[0]], Vworld[f[1]], Vworld[f[2]]
        n = np.cross(b - a, c - a)
        n_norm = np.linalg.norm(n)
        if n_norm > 1e-12:
            n = n / n_norm
        normals.append(n)
    normals = np.asarray(normals, float)

    return Vworld, faces, normals

# ---------- collision helpers ----------
def line_plane_intersection(n, p0, l0, l1, eps=1e-9):
    """Intersect segment l0->l1 with plane (n·(X - p0)=0)."""
    u = np.asarray(l1, float) - np.asarray(l0, float)
    denom = np.dot(n, u)
    if abs(denom) < eps:
        return None, False
    w = np.asarray(p0, float) - np.asarray(l0, float)
    sI = np.dot(n, w) / denom
    if sI < 0.0 or sI > 1.0:
        return None, False
    P = np.asarray(l0, float) + sI * u
    return P, True

def triangulate_face(face_idx):
    """Return triangle list from a 3/4/…-gon index list."""
    if len(face_idx) == 3:
        return [tuple(face_idx)]
    if len(face_idx) == 4:
        i0, i1, i2, i3 = face_idx
        return [(i0, i1, i2), (i0, i2, i3)]
    # generic fan
    out = []
    for k in range(1, len(face_idx)-1):
        out.append((face_idx[0], face_idx[k], face_idx[k+1]))
    return out

def point_in_triangle(P, A, B, C, eps=1e-9):
    """Barycentric point-in-triangle (coplanar)."""
    v0 = C - A
    v1 = B - A
    v2 = P - A
    dot00 = np.dot(v0, v0)
    dot01 = np.dot(v0, v1)
    dot02 = np.dot(v0, v2)
    dot11 = np.dot(v1, v1)
    dot12 = np.dot(v1, v2)
    denom = dot00 * dot11 - dot01 * dot01
    if abs(denom) < eps:
        return False
    u = (dot11 * dot02 - dot01 * dot12) / denom
    v = (dot00 * dot12 - dot01 * dot02) / denom
    return (u >= -eps) and (v >= -eps) and (u + v <= 1.0 + eps)

def get_link_points(robot, q=None):
    """Return Nx3 joint origins (base + each link end) in world."""
    if q is None:
        q = robot.q
    T_all = robot.fkine_all(q)
    pts = [robot.base.t.tolist()]
    for T in T_all:
        pts.append(T.t.tolist())
    return np.asarray(pts, float)

def check_env_collision(robot, q, vertices, faces, normals):
    """Segment–triangle collisions for all links vs environment faces."""
    pts = get_link_points(robot, q)
    hits = []
    for i in range(len(pts) - 1):
        A = pts[i]; B = pts[i+1]
        for fidx, face in enumerate(faces):
            n = normals[fidx]
            p0 = vertices[face[0]]
            P, ok = line_plane_intersection(n, p0, A, B)
            if not ok:
                continue
            for tri in triangulate_face(face):
                Atri, Btri, Ctri = vertices[tri[0]], vertices[tri[1]], vertices[tri[2]]
                if point_in_triangle(P, Atri, Btri, Ctri):
                    hits.append(P.tolist())
                    break
    return (len(hits) > 0), hits

# ---------- self-collision (coarse) ----------
def segment_segment_distance(P0, P1, Q0, Q1, eps=1e-9):
    u = P1 - P0
    v = Q1 - Q0
    w0 = P0 - Q0
    a = np.dot(u, u)
    b = np.dot(u, v)
    c = np.dot(v, v)
    d = np.dot(u, w0)
    e = np.dot(v, w0)
    denom = a * c - b * b
    if denom < eps:
        sc = 0.0
        tc = (e / c) if c > eps else 0.0
    else:
        sc = (b * e - c * d) / denom
        tc = (a * e - b * d) / denom
    sc = np.clip(sc, 0.0, 1.0)
    tc = np.clip(tc, 0.0, 1.0)
    dP = w0 + sc * u - tc * v
    return np.linalg.norm(dP)

def check_self_collision(robot, q, thresh=0.04):
    pts = get_link_points(robot, q)
    hit_pairs = []
    for i in range(len(pts) - 1):
        P0, P1 = pts[i], pts[i+1]
        for j in range(i + 2, len(pts) - 1):
            if j == i or j == i + 1:
                continue
            Q0, Q1 = pts[j], pts[j+1]
            if segment_segment_distance(np.asarray(P0), np.asarray(P1),
                                        np.asarray(Q0), np.asarray(Q1)) < thresh:
                hit_pairs.append((i, j))
    return (len(hit_pairs) > 0), hit_pairs

# ---------- simple RRT ----------
class Node:
    __slots__ = ("q", "parent")
    def __init__(self, q, parent=None):
        self.q = np.asarray(q, float)
        self.parent = parent

def qdist(q1, q2):
    return np.linalg.norm(np.asarray(q1) - np.asarray(q2))

def steer(q_from, q_to, step=0.18):
    dq = np.asarray(q_to) - np.asarray(q_from)
    nrm = np.linalg.norm(dq)
    if nrm <= step:
        return np.asarray(q_to)
    return np.asarray(q_from) + dq * (step / max(nrm, 1e-12))

def sample_q(robot):
    q = []
    for i in range(robot.n):
        try:
            qmin, qmax = robot.links[i].qlim
            q.append(np.random.uniform(qmin, qmax))
        except Exception:
            q.append(np.random.uniform(-pi, pi))
    return np.asarray(q, float)

def edge_is_collision_free(robot, q_a, q_b, VERT, FACES, NORMS):
    steps = int(max(2, np.ceil(qdist(q_a, q_b) / 0.09)))
    for lam in np.linspace(0, 1, steps):
        q = (1 - lam) * np.asarray(q_a) + lam * np.asarray(q_b)
        hit_env, _ = check_env_collision(robot, q, VERT, FACES, NORMS)
        if hit_env:
            return False
        hit_self, _ = check_self_collision(robot, q)
        if hit_self:
            return False
    return True

def rrt_plan(robot, q_start, q_goal, VERT, FACES, NORMS,
             max_nodes=2000, goal_thresh=0.15, step=0.18, bias=0.12):
    root = Node(q_start); nodes = [root]
    for _ in range(max_nodes):
        q_rand = q_goal if np.random.rand() < bias else sample_q(robot)
        idx = int(np.argmin([qdist(n.q, q_rand) for n in nodes]))
        q_new = steer(nodes[idx].q, q_rand, step)
        if edge_is_collision_free(robot, nodes[idx].q, q_new, VERT, FACES, NORMS):
            nn = Node(q_new, parent=nodes[idx]); nodes.append(nn)
            if qdist(q_new, q_goal) < goal_thresh:
                if edge_is_collision_free(robot, q_new, q_goal, VERT, FACES, NORMS):
                    goal_node = Node(q_goal, parent=nn)
                    path = []
                    cur = goal_node
                    while cur is not None:
                        path.append(cur.q)
                        cur = cur.parent
                    return list(reversed(path))
    return None

# ---------- Teach UI ----------
def teach_mode(robot, env, banner_label, env_geom):
    VERT, FACES, NORMS = env_geom

    def pose_strings():
        T = robot.fkine(robot.q)
        M = T.A if hasattr(T, "A") else T
        xyz = np.round(M[0:3, 3], 3)
        rpy = np.round(tr2rpy(M, unit="deg"), 2)
        return (
            f"X: {xyz[0]} m", f"Y: {xyz[1]} m", f"Z: {xyz[2]} m",
            f"Roll (φ): {rpy[0]}°", f"Pitch (θ): {rpy[1]}°", f"Yaw (ψ): {rpy[2]}°"
        )

    xs, ys, zs, rs, ps, ys2 = pose_strings()
    label_x = swift.Label(xs); env.add(label_x)
    label_y = swift.Label(ys); env.add(label_y)
    label_z = swift.Label(zs); env.add(label_z)
    label_r = swift.Label(rs); env.add(label_r)
    label_p = swift.Label(ps); env.add(label_p)
    label_yaw = swift.Label(ys2); env.add(label_yaw)
    labels = [label_x, label_y, label_z, label_r, label_p, label_yaw]

    def update_banner():
        env_hit, _ = check_env_collision(robot, robot.q, VERT, FACES, NORMS)
        self_hit, _ = check_self_collision(robot, robot.q)
        banner_label.desc = "⚠️  COLLISION DETECTED  ⚠️" if (env_hit or self_hit) else " "

    def on_slider(v_deg, j):
        q = list(robot.q)
        q[j] = np.deg2rad(v_deg)
        try:
            qmin, qmax = robot.links[j].qlim
            q[j] = float(np.clip(q[j], qmin, qmax))
        except Exception:
            pass
        robot.q = q
        xs, ys, zs, rs, ps, ys2 = pose_strings()
        label_x.desc, label_y.desc, label_z.desc = xs, ys, zs
        label_r.desc, label_p.desc, label_yaw.desc = rs, ps, ys2
        update_banner()

    for j in range(robot.n):
        try:
            qmin, qmax = robot.links[j].qlim
            mn_deg, mx_deg = float(np.rad2deg(qmin)), float(np.rad2deg(qmax))
        except Exception:
            mn_deg, mx_deg = -180.0, 180.0
        val_deg = float(np.rad2deg(robot.q[j]))
        slider = swift.Slider(cb=lambda v, jj=j: on_slider(v, jj),
                              min=mn_deg, max=mx_deg, step=1.0,
                              value=np.clip(val_deg, mn_deg, mx_deg),
                              desc=f"Joint {j+1}", unit='°')
        env.add(slider)

    update_banner()
    env.step(0.02)

# ---------- Main ----------
def main():
    env = swift.Swift()
    env.launch(realtime=True)

    robot = CR16()
    robot.add_to_env(env)

    env.set_camera_pose(position=[1.8, 1.6, 1.2], look_at=[0, 0, 0.5])

    # Obstacle: Cuboid (we'll compute its triangles ourselves)
    box = sg.Cuboid(scale=[0.40, 0.30, 0.28], color=[0.75, 0.45, 0.45, 1.0])
    box.T = SE3(0.55, -0.35, 0.14)   # center pose
    env.add(box)

    # Extract world-space mesh data robustly
    VERT, FACES, NORMS = cuboid_mesh_data(box)

    # Collision banner
    banner = swift.Label(" "); env.add(banner)

    # Teach UI + live collision
    teach_mode(robot, env, banner, (VERT, FACES, NORMS))

    status = swift.Label("status: idle"); env.add(status)

    def plan_and_go_cb(_=None):
        status.desc = "status: planning…"; env.step(0.02)

        bx, by, bz = T_translation(box.T)
        T_goal = SE3(bx - 0.3, by + 0.3 , bz + 0.22) * SE3.Rx(pi)  # hover near box, tool Z-down

        seed = robot.q
        sol = robot.ikine_LM(T_goal, q0=seed)
        if not sol.success:
            sol = robot.ikine_LM(T_goal, q0=seed, mask=[1,1,1,1,1,0])
        if not sol.success:
            sol = robot.ikine_LM(T_goal, q0=seed, mask=[1,1,1,0,0,0])

        if not sol.success:
            status.desc = "status: IK failed"; return

        q_goal = sol.q
        env_hit, _ = check_env_collision(robot, q_goal, VERT, FACES, NORMS)
        self_hit, _ = check_self_collision(robot, q_goal)
        if env_hit or self_hit:
            status.desc = "status: goal in collision (adjust offsets)"; return

        q_start = robot.q.copy()
        path = rrt_plan(robot, q_start, q_goal, VERT, FACES, NORMS,
                        max_nodes=2500, goal_thresh=0.18, step=0.20, bias=0.12)
        if path is None:
            status.desc = "status: RRT failed (tune step/goal)"; return

        status.desc = "status: executing…"
        for i in range(len(path) - 1):
            qa, qb = path[i], path[i+1]
            N = max(10, int(np.ceil(np.linalg.norm(qb-qa) / 0.06)))
            Q = rtb.jtraj(qa, qb, N).q
            for qk in Q:
                robot.q = qk
                env_hit, _ = check_env_collision(robot, robot.q, VERT, FACES, NORMS)
                self_hit, _ = check_self_collision(robot, robot.q)
                banner.desc = "⚠️  COLLISION DETECTED  ⚠️" if (env_hit or self_hit) else " "
                env.step(0.02)
                time.sleep(0.02)
        status.desc = "status: done"

    # Button to trigger the plan (fallback: auto-run once if Button missing)
    try:
        btn = swift.Button(desc="Plan & Go (avoid box)", cb=plan_and_go_cb)
        env.add(btn)
    except Exception:
        plan_and_go_cb()

    print("• Sliders move the CR3; red banner shows on collision.")
    print("• Click 'Plan & Go (avoid box)' to plan a collision-free path and execute with jtraj.")
    try:
        while True:
            env.step(0.02); time.sleep(0.02)
    except KeyboardInterrupt:
        env.close()

if __name__ == "__main__":
    main()
