#!/usr/bin/env python3
# teach_cr16.py — Swift teach panel with offset-aware sliders, E-STOP, live pose labels (no Reset)

from CR16Creator import CR16
import swift
import numpy as np
from spatialmath.base import tr2rpy
from spatialmath import UnitQuaternion

DT = 0.02  # ~50 Hz UI update


def teach_mode(robot, env):
    """
    UI:
      • Sliders per joint (deg for revolute, m for prismatic), showing MECHANICAL angle = q + offset.
      • Live pose labels: X/Y/Z + RPY + quaternion.
      • Buttons: E-STOP / Resume.
    Returns refresh_labels().
    """

    # ---- helpers ------------------------------------------------------------
    def current_T_matrix():
        T_obj = robot.fkine(robot.q)
        return T_obj.A if hasattr(T_obj, "A") else np.asarray(T_obj)

    def pose_strings():
        T = current_T_matrix()
        xyz = T[:3, 3]
        rpy = tr2rpy(T, unit="deg")  # ZYX
        quat = UnitQuaternion(T[:3, :3]).A  # [w, x, y, z]
        return (
            f"X: {xyz[0]:.3f} m",
            f"Y: {xyz[1]:.3f} m",
            f"Z: {xyz[2]:.3f} m",
            f"Roll (φ): {rpy[0]:.2f}°",
            f"Pitch (θ): {rpy[1]:.2f}°",
            f"Yaw (ψ): {rpy[2]:.2f}°",
            f"Quat: w={quat[0]:.3f}, x={quat[1]:.3f}, y={quat[2]:.3f}, z={quat[3]:.3f}",
        )

    # Offsets for mechanical-angle display (q_mech = q + offset)
    offsets = [float(getattr(L, "offset", 0.0)) for L in robot.links]

    # ---- labels -------------------------------------------------------------
    x_s, y_s, z_s, r_s, p_s, yaw_s, q_s = pose_strings()
    label_x = swift.Label(x_s);   env.add(label_x)
    label_y = swift.Label(y_s);   env.add(label_y)
    label_z = swift.Label(z_s);   env.add(label_z)
    label_r = swift.Label(r_s);   env.add(label_r)
    label_p = swift.Label(p_s);   env.add(label_p)
    label_yaw = swift.Label(yaw_s); env.add(label_yaw)
    label_quat = swift.Label(q_s);  env.add(label_quat)

    estop_label = swift.Label("E-STOP: DISENGAGED")
    env.add(estop_label)

    def refresh_labels():
        x_s, y_s, z_s, r_s, p_s, yaw_s, q_s = pose_strings()
        label_x.desc, label_y.desc, label_z.desc = x_s, y_s, z_s
        label_r.desc, label_p.desc, label_yaw.desc = r_s, p_s, yaw_s
        label_quat.desc = q_s

    # ---- E-STOP only --------------------------------------------------------
    paused = {"flag": False}

    def set_estop(active: bool):
        paused["flag"] = bool(active)
        estop_label.desc = "E-STOP: ENGAGED" if active else "E-STOP: DISENGAGED"

    def estop_cb(*_):  set_estop(True)
    def resume_cb(*_): set_estop(False)

    env.add(swift.Button(desc="E-STOP", cb=estop_cb))
    env.add(swift.Button(desc="Resume", cb=resume_cb))

    # ---- sliders ------------------------------------------------------------
    def add_joint_slider(j):
        link = robot.links[j]
        is_prismatic = getattr(link, "sigma", 0) == 1
        qlim = getattr(link, "qlim", None)
        off = offsets[j]

        if is_prismatic:
            if qlim is not None:
                ui_min, ui_max = float(qlim[0]), float(qlim[1])
            else:
                ui_min, ui_max = -1.0, 1.0
            value = float(robot.q[j])
            step, unit = 0.001, " m"

            def on_slider(v):
                if paused["flag"]:
                    return
                q = np.asarray(robot.q, float)
                q[j] = float(v)
                if qlim is not None:
                    q[j] = float(np.clip(q[j], float(qlim[0]), float(qlim[1])))
                robot.q = q.tolist()
                refresh_labels()

        else:
            if qlim is not None:
                ui_min = float(np.rad2deg(qlim[0] + off))
                ui_max = float(np.rad2deg(qlim[1] + off))
            else:
                ui_min, ui_max = -180.0, 180.0
            value = float(np.rad2deg(robot.q[j] + off))
            step, unit = 1.0, "°"

            def on_slider(v):
                if paused["flag"]:
                    return
                q = np.asarray(robot.q, float)
                q_int = np.deg2rad(float(v)) - off
                if qlim is not None:
                    q_int = float(np.clip(q_int, float(qlim[0]), float(qlim[1])))
                q[j] = q_int
                robot.q = q.tolist()
                refresh_labels()

        value = float(np.clip(value, ui_min, ui_max))
        slider = swift.Slider(cb=on_slider, min=ui_min, max=ui_max, step=step,
                              value=value, desc=f"Joint {j+1}", unit=unit)
        env.add(slider)

    for j in range(robot.n):
        add_joint_slider(j)

    env.step(DT)
    refresh_labels()
    return refresh_labels


# ---- Main -------------------------------------------------------------------
if __name__ == "__main__":
    env = swift.Swift()
    env.launch(realtime=True)

    robot = CR16()
    robot.add_to_env(env)

    refresh_labels = teach_mode(robot, env)

    try:
        while True:
            refresh_labels()
            env.step(DT)
    except KeyboardInterrupt:
        print("\nClosing Swift...")
        env.close()
